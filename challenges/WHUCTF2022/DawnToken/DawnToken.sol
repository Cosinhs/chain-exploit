// SPDX-License-Identifier: MIT

pragma solidity ^0.8.12;

import '@openzeppelin/contracts/token/ERC777/ERC777.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';
import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';
import '@uniswap/v2-periphery/contracts/interfaces/IWETH.sol';

/**
 * for WHUCTF(2022) blockchain puzzle (https://github.com/Dig2/chain-exploit/tree/main/challenges/WHUCTF2022/DawnToken)
 */

contract DawnToken is ERC777, Ownable {
    address public test;
    string private flag;
    uint256 public constant BASE = 10000;

    IUniswapV2Factory public constant UniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    IUniswapV2Router02 public constant UniswapV2Router02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IWETH public constant WETH = IWETH(0xc778417E063141139Fce010982780140Aa0cD5Ab);
    address public Dawn_WETH_pair;  /* IUniswapV2Pair */

    bool public transfer_enabled;  /* default false */
    mapping(address => uint256) public donates;
    mapping(address => bool) public claimed;

    /**
        `transfer`, `transferFrom` and `_send` are disabled when `transfer_enabled` is false
        `address(this)` is allowed as the recipient  because of uniswap pair operations
        `address(0)`    is allowed as `from` address because `mint` should be allowed.
     */
    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal override {
        require(from == address(0) || to == address(this) || transfer_enabled, "Dawn token: Swap disabled");
        super._beforeTokenTransfer(operator, from, to, amount);
    }

    /**
        Call this view function to get flag
     */
    function getFlag() public view returns(string memory) {
        if (balanceOf(_msgSender()) >= 2000 * 10**decimals()) {
            return flag;
        }
        return "qwq";
    }

    /**
        token name: Dawn token
        token symbol: DAWN
     */
    constructor(string memory _flag)
        ERC777("Dawn token", "DAWN", new address[](0))
        Ownable()
    {
        flag = _flag;
    }

    function donate() public payable {
        donates[_msgSender()] += msg.value;
    }

    function claimToken() public payable {
        require(claimed[_msgSender()] == false, "Dawn token: One address can only claim once");
        uint _donate = donates[_msgSender()];
        uint256 amount = (_donate > 0.1 ether ? 0.1 ether : _donate) * BASE;
        _mint(_msgSender(), amount, "", "", false);
        claimed[_msgSender()] = true;
    }


    /**
        One address can donate any number of times,
        but can only claim token for the first time and maximum is 1000.
        So use low-level-call for `claimToken` as it may be failed.
     */
    fallback() external payable {
        if (msg.sender != address(WETH)) {
            donate();
            address(this).delegatecall(abi.encodeWithSelector(this.claimToken.selector));
        }
    }


    function createPair() public payable onlyOwner {
        /* gas saving */
        address weth = address(WETH);

        /* create pair */
        UniswapV2Factory.createPair(address(this), weth);
        address pair = UniswapV2Factory.getPair(address(this), weth);
        Dawn_WETH_pair = pair;

        /* first liquidity injected: 1 ETH : 10000 Dawn */
        IWETH(weth).deposit{value: msg.value}();
        IWETH(weth).transfer(pair, msg.value);
        _mint(pair, msg.value * BASE, "", "", false);
        IUniswapV2Pair(pair).mint(address(this));
    }

    function removeLiquidity() public onlyOwner {
        /* gas saving */
        IWETH weth = WETH;
        IUniswapV2Pair pair = IUniswapV2Pair(Dawn_WETH_pair);

        /* send pair */
        pair.transfer(address(pair), pair.balanceOf(address(this)));

        /* burn liquidity */
        pair.burn(address(this));

        /* withdraw from WETH */
        weth.withdraw(weth.balanceOf(address(this)));
    }

    function withdraw(address payable _to, uint256 _amount) public onlyOwner {
        address to = _to == address(0) ? owner() : _to;
        uint256 amount = _amount == 0 ? address(this).balance : _amount;
        Address.sendValue(payable(to), amount);
    }

    function enable_transfer() public onlyOwner {
        transfer_enabled = true;
    }

    function disable_transfer() public onlyOwner {
        transfer_enabled = false;
    }
}
