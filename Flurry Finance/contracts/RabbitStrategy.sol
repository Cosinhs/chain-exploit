//SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "./BaseRhoStrategy.sol";
import "../interfaces/rabbit/IRbtBToken.sol";
import "../interfaces/rabbit/IRbtBank.sol";
import "../interfaces/rabbit/IRbtBankConfig.sol";
import "../interfaces/rabbit/IRbtFairLaunch.sol";
import "../interfaces/IPriceOracle.sol";
import "../interfaces/ITokenExchange.sol";

contract RabbitStrategy is BaseRhoStrategy {
    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;

    string public constant override NAME = "Rabbit";

    IRbtBank public rabbitBank;
    IRbtBankConfig public config;
    IRbtBToken public ibToken;
    IRbtFairLaunch public fairLaunch;
    IERC20MetadataUpgradeable public rabbit;

    IPriceOracle public rabbitUsdPriceOracle;
    ITokenExchange public tokenExchange;

    uint256 public poolId;

    uint256 constant GLO_VAL = 10000;

    function initialize(
        address _underlyingAddr,
        address _bankAddr,
        address _bankConfigAddr,
        address _fairLaunchAddr,
        address _tokenExchange,
        address _rabbitAddr,
        address _rabbitUsdPriceOracleAddr,
        address _ibTokenAddr,
        uint256 _poolId,
        uint256 _lockDurationInBlock,
        uint256 _blocksPerYear
    ) external initializer {
        BaseRhoStrategy.__initialize(_underlyingAddr, _lockDurationInBlock);
        rabbitBank = IRbtBank(_bankAddr);
        config = IRbtBankConfig(_bankConfigAddr);
        fairLaunch = IRbtFairLaunch(_fairLaunchAddr);
        ibToken = IRbtBToken(_ibTokenAddr);
        rabbit = IERC20MetadataUpgradeable(_rabbitAddr);
        tokenExchange = ITokenExchange(_tokenExchange);
        rabbitUsdPriceOracle = IPriceOracle(_rabbitUsdPriceOracleAddr);
        poolId = _poolId;
        BLOCK_PER_YEAR = _blocksPerYear;
    }

    function setFairLaunch(address _fairLaunchAddr) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_fairLaunchAddr != address(0), "zero addr for fairLaunch");
        fairLaunch = IRbtFairLaunch(_fairLaunchAddr);
    }

    /**
     * @notice current supply rate per block excluding bonus token RABBIT
     * @return supply rate per block, excluding yield from reward token
     */
    function supplyRatePerBlock() external view override returns (uint256) {
        return _supplyRate() / BLOCK_PER_YEAR;
    }

    /**
     * @param deposit The total amount of deposits
     * @return supply rate based on floating and deposit
     */
    function _supplyRate(uint256 deposit) internal view returns (uint256) {
        uint256 debt = rabbitBank.banks(address(underlying)).totalDebt;
        uint256 ratePerSec = config.getInterestRate(debt, deposit);
        return (ratePerSec * 365 days * (GLO_VAL - config.getReserveBps()) * debt) / (GLO_VAL * deposit);
    }

    function _supplyRate() internal view returns (uint256) {
        return _supplyRate(rabbitBank.totalToken(address(underlying)));
    }

    /**
     * @notice current supply rate excluding bonus token RABBIT
     * @return supply rate per year, excluding yield from reward token
     */
    function supplyRate() external view override returns (uint256) {
        return _supplyRate();
    }

    /**
     * @return RABBIT tokens distributed per block in the pool
     */
    function rabbitRewardPerBlock() internal view returns (uint256) {
        return
            (fairLaunch.rabbitPerBlock() * fairLaunch.poolInfo(poolId).allocPoint * 1e18) /
            fairLaunch.totalAllocPoint();
    }

    /**
     * @dev calculates the RABBIT bonus (in terms of USD) per block  as follows:
     * NOTE: Cannot apply multiply before divide pattern to retain precision because of overflow error
     */
    function _bonusRatePerBlock(uint256 totalStakes) internal view returns (uint256) {
        uint256 rabbitPerBlockPerUnderlying =
            (rabbitRewardPerBlock() * ibToken.totalSupply()) /
                (totalStakes * rabbitBank.totalToken(address(underlying)));
        return
            (rabbitPerBlockPerUnderlying * rabbitUsdPriceOracle.price(address(rabbit))) /
            10**rabbitUsdPriceOracle.decimals();
    }

    function _bonusPerBlockPerUnderlying() internal view returns (uint256 usdPerBlockPerUnderlying) {
        return _bonusRatePerBlock(ibToken.balanceOf(address(fairLaunch)));
    }

    /**
     * @notice current bonus rate per block for bonus token RABBIT
     * @return bonus supply rate per block
     */
    function bonusRatePerBlock() external view override returns (uint256) {
        return _bonusPerBlockPerUnderlying();
    }

    /**
     * @notice current bonus supply rate for bonus token RABBIT
     * @return bonus supply rate per year
     */
    function bonusSupplyRate() external view override returns (uint256) {
        return _bonusPerBlockPerUnderlying() * BLOCK_PER_YEAR;
    }

    /**
     * @notice effective supply rate of RabbitStrategy
     * @dev returns the effective supply rate from Rabbit protocol
     * taking into account rewards token RABBIT
     * @return supply rate per year, including yield from reward token (in wei)
     */
    function effectiveSupplyRate() external view override returns (uint256) {
        return _supplyRate() + _bonusPerBlockPerUnderlying() * BLOCK_PER_YEAR;
    }

    /**
     * @notice effective supply rate of RabbitStrategy
     * @dev returns the effective supply rate from Rabbit protocol
     * taking into account rewards token RABBIT AND the change in deployed amount.
     * @param delta magnitude of underlying to be deployed / withdrawn
     * @param isPositive true if `delta` is deployed, false if `delta` is withdrawn
     * @return supply rate per year, including yield from reward token (in wei)
     */
    function effectiveSupplyRate(uint256 delta, bool isPositive) external view override returns (uint256) {
        address token = address(underlying);

        uint256 newFloat = rabbitBank.totalToken(token);
        newFloat = isPositive ? newFloat + delta : newFloat - delta;

        uint256 ibDelta = rabbitBank.ibTokenCalculation(token, delta);
        uint256 newTotalStake = ibToken.balanceOf(address(fairLaunch));
        newTotalStake = isPositive ? newTotalStake + ibDelta : newTotalStake - ibDelta;

        return _supplyRate(newFloat) + _bonusRatePerBlock(newTotalStake) * BLOCK_PER_YEAR;
    }

    /**
     * @dev view function to return balance in underlying,
     * @return balance (interest included) from Rabbit protocol, in terms of underlying (in wei)
     */
    function balanceOfUnderlying() public view override returns (uint256) {
        return
            (fairLaunch.userInfo(poolId, address(this)).amount * rabbitBank.totalToken(address(underlying))) /
            ibToken.totalSupply();
    }

    function _updateBalanceOfUnderlying() internal override returns (uint256) {
        rabbitBank.calInterest(address(underlying));
        return balanceOfUnderlying();
    }

    /**
     * @dev deploy the underlying to Rabbit, deposit and stake ibTokens
     * @param _amount amount of underlying (in wei) to deploy
     */
    function deployInternal(uint256 _amount) internal override {
        underlying.safeIncreaseAllowance(address(rabbitBank), _amount);
        rabbitBank.deposit(address(underlying), _amount);

        uint256 pAmount = ibToken.balanceOf(address(this));
        ibToken.approve(address(fairLaunch), pAmount);
        fairLaunch.deposit(address(this), poolId, pAmount);
    }

    /**
     * @notice not all of the funds deployed to a strategy might be available for withdrawal
     * @return the amount of underlying tokens available for withdrawal from Rabbit strategy
     */
    function underlyingWithdrawable() public view override returns (uint256) {
        uint256 fairLaunchCash = ibToken.balanceOf(address(fairLaunch));
        uint256 fairLaunchBalance = fairLaunch.userInfo(poolId, address(this)).amount;
        uint256 balance = fairLaunchCash > fairLaunchBalance ? fairLaunchBalance : fairLaunchCash;
        uint256 pendingInterest =
            (config.getInterestRate(
                rabbitBank.banks(address(underlying)).totalDebt,
                rabbitBank.totalToken(address(underlying))
            ) *
                (block.timestamp - rabbitBank.banks(address(underlying)).lastInterestTime) *
                rabbitBank.banks(address(underlying)).totalDebt) / 1e18;
        balance =
            (balance *
                (rabbitBank.totalToken(address(underlying)) +
                    pendingInterest -
                    (pendingInterest * config.getReserveBps()) /
                    GLO_VAL)) /
            ibToken.totalSupply();
        uint256 cash = getCash();
        return cash > balance ? balance : cash;
    }

    /**
     * @dev Withdraw the amount in underlying from Rabbit protocol by unstake and withdraw ibTokens and transfer to vault
     * @notice Rabbit does not have function to withdraw underlying, need to convert amount in underlying to ibTokens, there is rounding error for conversion
     * @param _amount amount of underlying (in wei) to withdraw
     */
    function withdrawUnderlyingInternal(uint256 _amount) internal override {
        uint256 pendingInterest =
            (config.getInterestRate(
                rabbitBank.banks(address(underlying)).totalDebt,
                rabbitBank.totalToken(address(underlying))
            ) *
                (block.timestamp - rabbitBank.banks(address(underlying)).lastInterestTime) *
                rabbitBank.banks(address(underlying)).totalDebt) / 1e18;
        uint256 pAmount =
            (_amount * ibToken.totalSupply()) /
                (rabbitBank.totalToken(address(underlying)) +
                    pendingInterest -
                    (pendingInterest * config.getReserveBps()) /
                    GLO_VAL);
        fairLaunch.withdraw(address(this), poolId, pAmount);
        rabbitBank.withdraw(address(underlying), pAmount);
        underlying.safeTransfer(_msgSender(), underlying.balanceOf(address(this)));
    }

    /**
     * @dev Withdraw all underlying from Rabbit protocol by unstake and withdraw ibTokens and transfer to vault
     * ReentrancyGuard is already applied to withdrawAllCashAvailable in BaseRhoStrategy, hence not needed here
     */
    function withdrawAllCashAvailableInternal() internal override {
        uint256 balance = updateBalanceOfUnderlying();
        uint256 withdrawable = underlyingWithdrawable();
        if (balance > withdrawable) emit StrategyOutOfCash(balance, withdrawable);
        if (withdrawable == 0) {
            return;
        }
        fairLaunch.withdrawAll(address(this), poolId);
        rabbitBank.withdraw(address(underlying), ibToken.balanceOf(address(this)));
        underlying.safeTransfer(_msgSender(), underlying.balanceOf(address(this)));
    }

    /**
     * @dev Collect RABBIT tokens available and sell into underlying for the strategy
     */
    function collectRewardToken() external override onlyRole(VAULT_ROLE) whenNotPaused nonReentrant {
        if (address(rabbit) != address(0) && address(tokenExchange) != address(0)) {
            if (fairLaunch.userInfo(poolId, address(this)).amount != 0) {
                fairLaunch.harvest(poolId);
            }
            rabbit.safeIncreaseAllowance(address(tokenExchange), rabbit.balanceOf(address(this)));
            tokenExchange.sellExactInput(rabbit, underlying, _msgSender(), rabbit.balanceOf(address(this)));
        }
    }

    /**
     * @return address of RABBIT token contract
     */
    function bonusToken() external view override returns (address) {
        return address(rabbit);
    }

    /**
     * @return RABBIT tokens accrued
     */
    function bonusTokensAccrued() external view override returns (uint256) {
        return fairLaunch.pendingRabbit(poolId, address(this));
    }

    /**
     * @param rewardCollectThreshold minimum threshold for collecting RABBIT token
     * @return true if reward in underlying > `rewardCollectThreshold`, false otherwise
     */
    function shouldCollectReward(uint256 rewardCollectThreshold) external view override returns (bool) {
        uint256 rabbitPrice = rabbitUsdPriceOracle.price(address(rabbit));
        uint256 rabbitQty = rabbit.balanceOf(address(this)) + fairLaunch.pendingRabbit(poolId, address(this));
        uint256 minUnderlyingQty =
            (rabbitQty * rabbitPrice * 10**underlying.decimals()) /
                10**(rabbit.decimals() + rabbitUsdPriceOracle.decimals());
        return minUnderlyingQty > rewardCollectThreshold;
    }

    /**
     * @dev admin function - withdraw random token transfer to this contract
     */
    function sweepERC20Token(address token, address to) external override onlyRole(SWEEPER_ROLE) {
        require(token != address(underlying), "!safe");
        require(token != address(ibToken), "!safe");
        require(token != address(rabbit), "!safe");
        super._sweepERC20Token(token, to);
    }

    /**
     * @return amount of underlying holds by Rabbit (ibTokens)
     */
    function getCash() internal view override returns (uint256) {
        return underlying.balanceOf(address(rabbitBank));
    }
}
