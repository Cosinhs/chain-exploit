//SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "../interfaces/IRhoTokenRewards.sol";
import "../interfaces/IRhoToken.sol";

contract RhoToken is IRhoToken, ERC20Upgradeable, AccessControlEnumerableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;

    /**
     * @dev internally stored without any multiplier
     */
    mapping(address => uint256) private _balances;

    /**
     * @dev this mapping is valid only for addresses that have already changed their options.
     * To query an account's rebase option, call `isRebasingAccount()` externally
     * or `_isRebasingAccount()` internally.
     */
    mapping(address => RebaseOption) private _rebaseOptions;

    uint256 private _rebasingTotalSupply;
    uint256 private _nonRebasingTotalSupply;

    uint256 private constant ONE = 1e36;
    uint256 private multiplier;
    address public tokenRewardsAddress;
    uint256 public lastUpdateTime;

    bytes32 public constant VAULT_ROLE = keccak256("VAULT_ROLE");
    bytes32 public constant SWEEPER_ROLE = keccak256("SWEEPER_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    bool private _paused;
    address public override underlying;

    event Paused(address account);
    event Unpaused(address account);

    function __initialize(
        string memory name_,
        string memory symbol_,
        address underlyingAddr_
    ) external initializer {
        ERC20Upgradeable.__ERC20_init(name_, symbol_);
        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();
        _setMultiplier(ONE);
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setUnderlying(underlyingAddr_);
    }

    function totalSupply() public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {
        return _timesMultiplier(_rebasingTotalSupply) + _nonRebasingTotalSupply;
    }

    function adjustedRebasingSupply() external view override returns (uint256) {
        return _timesMultiplier(_rebasingTotalSupply);
    }

    function unadjustedRebasingSupply() external view override returns (uint256) {
        return _rebasingTotalSupply;
    }

    function nonRebasingSupply() external view override returns (uint256) {
        return _nonRebasingTotalSupply;
    }

    function balanceOf(address account) public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {
        if (isRebasingAccount(account)) {
            return _timesMultiplier(_balances[account]);
        }
        return _balances[account];
    }

    function getOwner() external view override returns (address) {
        if (getRoleMemberCount(DEFAULT_ADMIN_ROLE) == 0) {
            return address(0);
        }
        return getRoleMember(DEFAULT_ADMIN_ROLE, 0);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override setDefaultRebasingOption(from) setDefaultRebasingOption(to) {
        super._beforeTokenTransfer(from, to, amount);
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override updateTokenRewards(sender) updateTokenRewards(recipient) whenNotPaused {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        _beforeTokenTransfer(sender, recipient, amount);

        // deducting from sender
        uint256 amountToDeduct = amount;
        if (_isRebasingAccount(sender)) {
            amountToDeduct = _dividedByMultiplier(amount);
            require(_balances[sender] >= amountToDeduct, "ERC20: transfer amount exceeds balance");
            _rebasingTotalSupply -= amountToDeduct;
        } else {
            require(_balances[sender] >= amountToDeduct, "ERC20: transfer amount exceeds balance");
            _nonRebasingTotalSupply -= amountToDeduct;
        }
        _balances[sender] -= amountToDeduct;
        // adding to recipient
        uint256 amountToAdd = amount;
        if (_isRebasingAccount(recipient)) {
            amountToAdd = _dividedByMultiplier(amount);
            _rebasingTotalSupply += amountToAdd;
        } else {
            _nonRebasingTotalSupply += amountToAdd;
        }
        _balances[recipient] += amountToAdd;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal override {
        require(account != address(0), "ERC20: mint to the zero address");
        _beforeTokenTransfer(address(0), account, amount);

        uint256 amountToAdd = amount;
        if (_isRebasingAccount(account)) {
            amountToAdd = _dividedByMultiplier(amount);
            _rebasingTotalSupply += amountToAdd;
        } else {
            _nonRebasingTotalSupply += amountToAdd;
        }
        _balances[account] += amountToAdd;
        emit Transfer(address(0), account, amount);
        emit RhoTokenSupplyChanged(totalSupply(), _timesMultiplier(_rebasingTotalSupply), _nonRebasingTotalSupply);
    }

    function _burn(address account, uint256 amount) internal override {
        require(account != address(0), "ERC20: burn from the zero address");
        _beforeTokenTransfer(account, address(0), amount);

        uint256 amountToDeduct = amount;
        if (_isRebasingAccount(account)) {
            amountToDeduct = _dividedByMultiplier(amount);
            require(_balances[account] >= amountToDeduct, "ERC20: burn amount exceeds balance");
            _rebasingTotalSupply -= amountToDeduct;
        } else {
            require(_balances[account] >= amountToDeduct, "ERC20: burn amount exceeds balance");
            _nonRebasingTotalSupply -= amountToDeduct;
        }
        _balances[account] -= amountToDeduct;
        emit Transfer(account, address(0), amount);
        emit RhoTokenSupplyChanged(totalSupply(), _timesMultiplier(_rebasingTotalSupply), _nonRebasingTotalSupply);
    }

    /* multiplier */
    function setMultiplier(uint256 multiplier_) external override onlyRole(VAULT_ROLE) updateTokenRewards(address(0)) {
        _setMultiplier(multiplier_);
        emit RhoTokenSupplyChanged(totalSupply(), _timesMultiplier(_rebasingTotalSupply), _nonRebasingTotalSupply);
    }

    function _setMultiplier(uint256 multiplier_) internal {
        uint256 oldMultiplier = multiplier;
        multiplier = multiplier_;
        lastUpdateTime = block.timestamp;
        emit MultiplierChange(oldMultiplier, multiplier);
    }

    function getMultiplier() external view override returns (uint256 _multiplier, uint256 _lastUpdateTime) {
        _multiplier = multiplier;
        _lastUpdateTime = lastUpdateTime;
    }

    function mint(address account, uint256 amount) external override onlyRole(MINTER_ROLE) updateTokenRewards(account) {
        require(amount > 0, "amount must be greater than zero");
        return _mint(account, amount);
    }

    function burn(address account, uint256 amount) external override onlyRole(BURNER_ROLE) updateTokenRewards(account) {
        require(amount > 0, "amount must be greater than zero");
        return _burn(account, amount);
    }

    /* utils */
    function _timesMultiplier(uint256 input) internal view returns (uint256) {
        return (input * multiplier) / ONE;
    }

    function _dividedByMultiplier(uint256 input) internal view returns (uint256) {
        return (input * ONE) / multiplier;
    }

    function setRebasingOption(bool isRebasing) external override {
        uint256 userBalance = _balances[_msgSender()];

        if (isRebasing && _rebaseOptions[_msgSender()] != RebaseOption.REBASING) {
            _rebaseOptions[_msgSender()] = RebaseOption.REBASING;
            _nonRebasingTotalSupply -= userBalance;
            _rebasingTotalSupply += _dividedByMultiplier(userBalance);
            _balances[_msgSender()] = _dividedByMultiplier(userBalance);
        } else if (!isRebasing && _rebaseOptions[_msgSender()] != RebaseOption.NON_REBASING) {
            _rebaseOptions[_msgSender()] = RebaseOption.NON_REBASING;
            _rebasingTotalSupply -= userBalance;
            _nonRebasingTotalSupply += _timesMultiplier(userBalance);
            _balances[_msgSender()] = _timesMultiplier(userBalance);
        }
        emit RhoTokenSupplyChanged(totalSupply(), _timesMultiplier(_rebasingTotalSupply), _nonRebasingTotalSupply);
        emit SetRebasingOption(_msgSender(), _rebaseOptions[_msgSender()]);
    }

    function _isRebasingAccount(address account) internal view returns (bool) {
        require(_rebaseOptions[account] != RebaseOption.UNKNOWN, "rebasing option not set");
        return (_rebaseOptions[account] == RebaseOption.REBASING);
    }

    function isRebasingAccount(address account) public view override returns (bool) {
        return
            (_rebaseOptions[account] == RebaseOption.REBASING) ||
            (_rebaseOptions[account] == RebaseOption.UNKNOWN && !account.isContract());
    }

    /* token rewards */
    function setTokenRewards(address tokenRewards) external override onlyRole(DEFAULT_ADMIN_ROLE) {
        tokenRewardsAddress = tokenRewards;
    }

    // withdraw random token transfer into this contract
    function sweepERC20Token(address token, address to) external override onlyRole(SWEEPER_ROLE) {
        require(token != address(this), "!safe");
        IERC20Upgradeable tokenToSweep = IERC20Upgradeable(token);
        tokenToSweep.safeTransfer(to, tokenToSweep.balanceOf(address(this)));
    }

    function paused() external view override returns (bool) {
        return _paused;
    }

    function _pause() internal whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }

    function pause() external override onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external override onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function _setUnderlying(address addr) internal {
        require(addr != address(0), "underlying address is 0");
        underlying = addr;
        emit SetUnderlying(addr);
    }

    function setUnderlying(address addr) external override onlyRole(DEFAULT_ADMIN_ROLE) {
        _setUnderlying(addr);
    }

    /* ========== MODIFIERS ========== */
    modifier updateTokenRewards(address account) {
        if (tokenRewardsAddress != address(0)) {
            IRhoTokenRewards(tokenRewardsAddress).updateReward(account, address(this));
        }
        _;
    }

    modifier setDefaultRebasingOption(address account) {
        // defaults to either REBASING or NON_REBASING, depending on whether account is a contract
        // note the isContract() could be volatile, i.e. an EOA can turn into a contract in the future
        // hence we set it to a value 1st time the account address is used in a transfer
        // account owner still has the ability to change this option via setRebasingOption() at any moment
        if (_rebaseOptions[account] == RebaseOption.UNKNOWN)
            _rebaseOptions[account] = account.isContract() ? RebaseOption.NON_REBASING : RebaseOption.REBASING;
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, "Pausable: paused");
        _;
    }

    modifier whenPaused() {
        require(_paused, "Pausable: not paused");
        _;
    }
}
